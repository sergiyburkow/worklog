generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String                 @id @default(uuid())
  name             String
  email            String?                @unique
  phone            String?
  passwordHash     String?                @map("password_hash")
  role             UserRole               @default(WORKER)
  callSign         String?
  createdAt        DateTime               @default(now())
  lastName         String?
  updatedAt        DateTime               @updatedAt
  createdPayments  Payment[]              @relation("CreatedPayments")
  receivedPayments Payment[]              @relation("ReceivedPayments")
  projects         ProjectUser[]
  statusHistory    TaskLogStatusHistory[]
  skills           UserSkill[]
  tokens           UserToken[]
  taskLogs         TaskLog[]              @relation("CreatedBy")

  @@map("Users")
}

model UserToken {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  jwtToken  String   @map("jwt_token")
  expiresAt DateTime @map("expires_at")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("UserTokens")
}

model Client {
  id          String          @id @default(uuid())
  name        String
  description String?
  address     String?
  contactInfo String?         @map("contact_info")
  contacts    ClientContact[]
  projects    Project[]

  @@map("Clients")
}

model ClientContact {
  id        String  @id @default(uuid())
  clientId  String  @map("client_id")
  name      String
  email     String?
  phone     String?
  telegram  String?
  whatsapp  String?
  signal    String?
  messenger String?
  instagram String?
  facebook  String?
  client    Client  @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@map("ClientContacts")
}

model Project {
  id            String         @id @default(uuid())
  name          String
  projectCode   String?        @map("project_code")
  clientId      String         @map("client_id")
  startDate     DateTime       @map("start_date")
  deadline      DateTime
  actualEndDate DateTime?      @map("actual_end_date")
  status        ProjectStatus  @default(NEW)
  quantity      Int?
  updatedAt     DateTime       @updatedAt @map("updated_at")
  payments      Payment[]
  products      Product[]
  users         ProjectUser[]
  client        Client         @relation(fields: [clientId], references: [id], onDelete: Cascade)
  tasks         Task[]
  taskGroups    TaskGroup[]
  parts         Part[]
  partGroups    PartGroup[]
  inventoryLogs InventoryLog[]

  @@map("Projects")
}

model ProjectUser {
  userId    String          @map("user_id")
  projectId String          @map("project_id")
  role      ProjectUserRole @map("role")
  isActive  Boolean         @default(true)
  project   Project         @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, projectId])
  @@map("ProjectUsers")
}

model Task {
  id            String                @id @default(uuid())
  name          String
  description   String?
  type          TaskType              @default(GENERAL)
  status        TaskStatus            @default(NEW)
  complexity    Int?
  tags          String?
  estimatedTime Decimal?              @map("estimated_time")
  projectId     String                @map("project_id")
  groupId       String?               @map("group_id")
  createdAt     DateTime              @default(now()) @map("created_at")
  updatedAt     DateTime              @updatedAt @map("updated_at")
  cost          Decimal               @default(0) @map("cost")
  logs          TaskLog[]
  project       Project               @relation(fields: [projectId], references: [id], onDelete: Cascade)
  group         TaskGroup?            @relation(fields: [groupId], references: [id], onDelete: SetNull)
  outputParts   TaskOutputPart[]
  consumedParts TaskPartConsumption[]

  @@index([projectId, groupId])
  @@map("tasks")
}

/// Task grouping: groups of tasks within a project
model TaskGroup {
  id          String   @id @default(uuid())
  projectId   String   @map("project_id")
  name        String
  description String?
  sortOrder   Int      @default(0) @map("sort_order")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  tasks       Task[]

  @@index([projectId, sortOrder])
  @@map("TaskGroups")
}

model Product {
  id        String    @id @default(uuid())
  code      String
  projectId String    @map("project_id")
  createdAt DateTime  @default(now()) @map("created_at")
  cost      Decimal   @default(0)
  project   Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  taskLogs  TaskLog[]

  @@unique([code, projectId])
  @@map("Products")
}

model TaskLog {
  id            String                 @id @default(uuid())
  userId        String                 @map("user_id")
  taskId        String                 @map("task_id")
  productId     String?                @map("product_id")
  completedAt   DateTime?              @map("completed_at")
  registeredAt  DateTime               @map("registered_at")
  timeSpent     Decimal?               @map("time_spent")
  quantity      Int?                   @map("quantity")
  cost          Decimal                @default(0) @map("cost")
  statusHistory TaskLogStatusHistory[]
  product       Product?               @relation(fields: [productId], references: [id])
  task          Task                   @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user          User                   @relation("CreatedBy", fields: [userId], references: [id], onDelete: Cascade)

  @@map("task_logs")
}

model TaskLogStatusHistory {
  id        String                @id @default(uuid())
  taskLogId String                @map("task_log_id")
  status    TaskLogApprovalStatus
  userId    String                @map("user_id")
  createdAt DateTime              @default(now()) @map("created_at")
  taskLog   TaskLog               @relation(fields: [taskLogId], references: [id], onDelete: Cascade)
  user      User                  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("TaskLogStatusHistory")
}

model Skill {
  id    String      @id @default(uuid())
  name  String      @unique
  users UserSkill[]

  @@map("Skills")
}

model UserSkill {
  userId  String @map("user_id")
  skillId String @map("skill_id")
  skill   Skill  @relation(fields: [skillId], references: [id], onDelete: Cascade)
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, skillId])
  @@map("UserSkills")
}

model Payment {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  projectId   String   @map("project_id")
  createdById String   @map("created_by_id")
  amount      Decimal
  date        DateTime @default(now())
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  createdBy   User     @relation("CreatedPayments", fields: [createdById], references: [id])
  project     Project  @relation(fields: [projectId], references: [id])
  user        User     @relation("ReceivedPayments", fields: [userId], references: [id])

  @@map("Payments")
}

enum UserRole {
  ADMIN
  PROJECT_MANAGER
  WORKER
  GUEST
}

enum ProjectUserRole {
  MANAGER
  QA
  ENGINEER
  PADAWAN
}

enum ProjectStatus {
  PLANNED
  NEW
  IN_PROGRESS
  ON_HOLD
  COMPLETED
  SHIPPED
  REJECTED
  FINISHED
}

enum TaskStatus {
  NEW
  IN_PROGRESS
  COMPLETED
  ON_HOLD
}

enum TaskType {
  PRODUCT
  GENERAL
  INTERMEDIATE
}

enum TaskLogStatus {
  NEW
  IN_PROGRESS
  COMPLETED
  ON_HOLD
}

enum TaskLogApprovalStatus {
  APPROVED
  NEEDS_FIXES
  ON_HOLD
}

/// Inventory: grouping of parts per project
model PartGroup {
  id          String  @id @default(uuid())
  projectId   String  @map("project_id")
  name        String
  description String?
  sortOrder   Int     @default(0) @map("sort_order")
  project     Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  parts       Part[]

  @@map("PartGroups")
}

/// Inventory: part definition per project
model Part {
  id              String                @id @default(uuid())
  projectId       String                @map("project_id")
  code            String
  name            String
  description     String?
  groupId         String?               @map("group_id")
  unit            String?               @default("pcs")
  targetQuantity  Int?                  @map("target_quantity")
  isActive        Boolean               @default(true) @map("is_active")
  project         Project               @relation(fields: [projectId], references: [id], onDelete: Cascade)
  group           PartGroup?            @relation(fields: [groupId], references: [id])
  logs            InventoryLog[]
  outputForTasks  TaskOutputPart[]
  consumedByTasks TaskPartConsumption[]

  @@unique([projectId, code])
  @@index([projectId, groupId])
  @@map("Parts")
}

/// Inventory: immutable movement log
model InventoryLog {
  id          String           @id @default(uuid())
  projectId   String           @map("project_id")
  partId      String           @map("part_id")
  type        InventoryLogType
  quantity    Decimal
  unitPrice   Decimal?         @map("unit_price") /// Ціна за одиницю (тільки для закупівель)
  note        String?
  createdAt   DateTime         @default(now()) @map("created_at")
  createdById String           @map("created_by_id")
  taskLogId   String?
  project     Project          @relation(fields: [projectId], references: [id], onDelete: Cascade)
  part        Part             @relation(fields: [partId], references: [id], onDelete: Cascade)

  // Note: We use logical idempotency in application code (check taskLogId + partId before create)
  // instead of database constraints to avoid issues with NULL values and database state synchronization
  @@index([taskLogId, partId]) // Non-unique index for query performance
  @@index([projectId, partId, createdAt(sort: Desc)])
  @@map("InventoryLogs")
}

/// Inventory recipe: output part produced per unit of task quantity
model TaskOutputPart {
  taskId  String  @map("task_id")
  partId  String  @map("part_id")
  perUnit Decimal @map("per_unit")
  task    Task    @relation(fields: [taskId], references: [id], onDelete: Cascade)
  part    Part    @relation(fields: [partId], references: [id])

  @@id([taskId, partId])
  @@map("TaskOutputParts")
}

/// Inventory recipe: parts consumed per unit of task quantity
model TaskPartConsumption {
  taskId          String  @map("task_id")
  partId          String  @map("part_id")
  quantityPerUnit Decimal @map("quantity_per_unit")
  task            Task    @relation(fields: [taskId], references: [id], onDelete: Cascade)
  part            Part    @relation(fields: [partId], references: [id])

  @@id([taskId, partId])
  @@map("TaskPartConsumptions")
}

enum InventoryLogType {
  PURCHASE
  PRODUCTION
  ADJUSTMENT
}
